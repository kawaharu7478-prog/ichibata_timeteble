<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>一畑電車 運行表示</title>
<style>
  body { font-family: sans-serif; text-align: center; }
  #time { font-size: 24px; margin: 10px; font-weight: bold; }
  canvas { border:1px solid #ccc; }
</style>
</head>
<body>
  <div id="time"></div>
  <canvas id="canvas" width="1400" height="400"></canvas>

<script>
const stations1 = ["松江温泉","ガーデン前","朝日ヶ丘","長江","秋鹿町","フォーゲル","高ノ宮","津ノ森","伊野灘","一畑口","園","湖遊館新駅","布崎","雲州平田","旅伏","美談","大寺","川跡","武志","大津町","科学館前","電鉄出雲市"];
const stations2 = ["川跡","高浜","遥堪","浜山公園北口","出雲大社前"];

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const spacing = 55;
const baseY = 200;
const branchY = 300;

function parseTime(str) {
  if (!str || str.trim()==="") return null;
  const num = parseInt(str,10);
  if(isNaN(num)) return null;
  const h = Math.floor(num / 100);
  const m = num % 100;
  return h * 60 + m;
}

function getCurrentMinutes() {
  const d = new Date();
  return d.getHours()*60 + d.getMinutes();
}

function getTrainColor(train_name) {
  if (train_name.includes("A")) return {bg: "red", fg: "white"};
  if (train_name.includes("B")) return {bg: "green", fg: "white"};
  if (train_name.includes("C")) return {bg: "yellow", fg: "black"};
  if (train_name.includes("D")) return {bg: "blue", fg: "black"};
  if (train_name.includes("E")) return {bg: "transparent", fg: "black", border:"black"};
  if (train_name.includes("F")) return {bg: "cyan", fg: "black"};
  if (train_name.includes("G")) return {bg: "orange", fg: "white"};
  if (train_name.includes("H")) return {bg: "pink", fg: "black"};
  if (train_name.includes("I")) return {bg: "limegreen", fg: "black"};
  return {bg: "gray", fg: "white"};
}

function drawTrainIcon(x,y,train,direction) {
  const {bg,fg,border} = getTrainColor(train.train_name);
  ctx.font = "12px sans-serif";
  const textW = ctx.measureText(train.train_name).width;
  const w = textW+10, h=20;
  ctx.beginPath();
  if(direction==="up"){
    ctx.rect(x-w/2, y-h-10, w, h);
    ctx.moveTo(x+w/2, y-h-10);
    ctx.lineTo(x+w/2+10, y-h/2-10);
    ctx.lineTo(x+w/2, y-10);
  } else {
    ctx.rect(x-w/2, y+10, w, h);
    ctx.moveTo(x-w/2, y+10);
    ctx.lineTo(x-w/2-10, y+h/2+10);
    ctx.lineTo(x-w/2, y+h+10);
  }
  ctx.closePath();
  if(bg!=="transparent"){
    ctx.fillStyle = bg;
    ctx.fill();
  }
  if(border){
    ctx.strokeStyle=border;
    ctx.stroke();
  }
  ctx.fillStyle = fg;
  ctx.textBaseline="middle";
  const ty = direction==="up"? y-h/2-10 : y+h/2+10;
  ctx.fillText(train.train_name, x-textW/2, ty);
}

function drawScene(trains) {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 路線1
  ctx.beginPath();
  ctx.moveTo(50, baseY);
  ctx.lineTo(50+spacing*(stations1.length-1), baseY);
  ctx.stroke();
  stations1.forEach((s,i)=>{
    const x=50+i*spacing;
    ctx.fillText(s, x-10, baseY-10);
  });

  // 路線2
  const kawatoX = 50+stations1.indexOf("川跡")*spacing;
  ctx.beginPath();
  ctx.moveTo(kawatoX, baseY);
  ctx.lineTo(kawatoX+spacing*(stations2.length-1), branchY);
  ctx.stroke();
  stations2.forEach((s,i)=>{
    const x=kawatoX+i*spacing;
    ctx.fillText(s, x-10, branchY+25);
  });

  const now = getCurrentMinutes();
  document.getElementById("time").textContent =
      new Date().toLocaleTimeString('ja-JP',{hour12:false});

  trains.forEach(train=>{
    const allStations = [...stations1, ...stations2.slice(1)];
    const times = allStations.map(s=>parseTime(train[s]));

    // 始発〜終着の範囲のみ表示
    const validTimes = times.filter(t=>t!==null);
    if(validTimes.length<2) return;
    if(now < Math.min(...validTimes)) return;
    if(now > Math.max(...validTimes)) return;

    for(let i=0;i<allStations.length-1;i++){
      const t1 = times[i], t2 = times[i+1];
      if(t1!==null && t2!==null && now>=t1 && now<=t2){
        let ratio = (now-t1)/(t2-t1);
        let x1=50+i*spacing, x2=50+(i+1)*spacing;
        let y1 = (allStations[i]==="川跡")?baseY:(stations2.includes(allStations[i])?branchY:baseY);
        let y2 = (allStations[i+1]==="川跡")?baseY:(stations2.includes(allStations[i+1])?branchY:baseY);
        let x=x1+(x2-x1)*ratio, y=y1+(y2-y1)*ratio;
        drawTrainIcon(x,y,train,train.direction);
      }
    }
  });
}

// CSV 読み込み
async function loadCSV() {
  const res = await fetch("trains.csv");
  const text = await res.text();
  const lines = text.trim().split(/\r?\n/);
  const headers = lines[0].split(",");
  const trains = lines.slice(1).map(line=>{
    const cols = line.split(",");
    let obj={};
    headers.forEach((h,i)=>{ obj[h]=cols[i] || ""; });
    return obj;
  });
  return trains;
}

loadCSV().then(trains=>{
  setInterval(()=>drawScene(trains),1000);
});
</script>
</body>
</html>
