<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>列車運行ダイヤ図</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }
    .station {
      font-size: 12px;
    }
    .line {
      stroke: black;
      stroke-width: 2px;
      fill: none;
    }
  </style>
</head>
<body>
  <div id="diagram"></div>

  <script>
    const width = 1200;
    const height = 800;

    const svg = d3.select("#diagram")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    // ===== 現在時刻表示 =====
    function formatTime(date) {
      return d3.timeFormat("%H%M")(date);
    }

    const currentTimeText = svg.append("text")
      .attr("x", width / 2)
      .attr("y", 30)
      .attr("text-anchor", "middle")
      .attr("font-size", "24px")
      .attr("font-weight", "bold");

    function updateClock() {
      const now = new Date();
      currentTimeText.text(formatTime(now));
    }
    setInterval(updateClock, 1000);
    updateClock();

    // ===== 駅データ =====
    const stationsUp = [
      "松江温泉","ガーデン前","朝日ヶ丘","長江","秋鹿町","フォーゲル","高ノ宮","津ノ森","伊野灘","一畑口",
      "園","湖遊館新駅","布崎","雲州平田","旅伏","美談","大寺","川跡","武志","大津町","科学館前","電鉄出雲市"
    ];
    const stationsDown = [
      "川跡","高浜","遥堪","浜山公園北口","出雲大社前"
    ];

    // 座標設定
    const baseX = 200;
    const baseY = 200;
    const spacing = 40;
    const branchDrop = 80;  // 川跡から下に落とす距離

    const stationPos = {};
    stationsUp.forEach((name, i) => {
      stationPos[name] = {x: baseX + i * spacing, y: baseY};
    });

    const kawaPos = stationPos["川跡"];
    const branchStart = {x: kawaPos.x, y: kawaPos.y + branchDrop};

    stationsDown.forEach((name, i) => {
      if (i === 0) {
        stationPos[name] = kawaPos; // 川跡は本線上
      } else {
        stationPos[name] = {x: branchStart.x + i * spacing, y: branchStart.y};
      }
    });

    // 線路描画
    svg.append("polyline")
      .attr("points", stationsUp.map(s => `${stationPos[s].x},${stationPos[s].y}`).join(" "))
      .attr("class", "line");

    svg.append("line")
      .attr("x1", kawaPos.x).attr("y1", kawaPos.y)
      .attr("x2", branchStart.x).attr("y2", branchStart.y)
      .attr("class", "line");

    svg.append("polyline")
      .attr("points", stationsDown.slice(1).map(s => `${stationPos[s].x},${stationPos[s].y}`).join(" "))
      .attr("class", "line");

    // 駅マーク
    Object.entries(stationPos).forEach(([name, pos]) => {
      svg.append("circle")
        .attr("cx", pos.x)
        .attr("cy", pos.y)
        .attr("r", 4)
        .attr("fill", "black");
      svg.append("text")
        .attr("x", pos.x)
        .attr("y", pos.y - 10)
        .attr("text-anchor", "middle")
        .attr("class", "station")
        .text(name);
    });

    // ===== CSV読み込み =====
    d3.csv("trains.csv").then(function(data) {
      const trainGroup = svg.append("g").attr("class", "trains");

      function parseTime(t) {
        if (!t || isNaN(t)) return null;
        return parseInt(t);
      }

      function getTrainPosition(d, now) {
        const stations = Object.keys(d).slice(3); // train_id, train_name, direction を除く
        let prev = null, next = null;

        for (let i = 0; i < stations.length; i++) {
          const t = parseTime(d[stations[i]]);
          if (t && t <= now) prev = {station: stations[i], time: t};
          if (t && t > now) { next = {station: stations[i], time: t}; break; }
        }

        if (!prev || !next) return null;

        const p1 = stationPos[prev.station];
        const p2 = stationPos[next.station];
        if (!p1 || !p2) return null;

        const ratio = (now - prev.time) / (next.time - prev.time);
        const x = p1.x + (p2.x - p1.x) * ratio;
        const y = p1.y + (p2.y - p1.y) * ratio;

        return {x, y, direction: d.direction};
      }

      function getStyle(train_name) {
        if (train_name.includes("A")) return {fill: "red", text: "white"};
        if (train_name.includes("B")) return {fill: "green", text: "white"};
        if (train_name.includes("C")) return {fill: "yellow", text: "black"};
        if (train_name.includes("D")) return {fill: "blue", text: "black"};
        if (train_name.includes("E")) return {fill: "none", text: "black"};
        if (train_name.includes("F")) return {fill: "cyan", text: "black"};
        if (train_name.includes("G")) return {fill: "orange", text: "white"};
        if (train_name.includes("H")) return {fill: "pink", text: "black"};
        if (train_name.includes("I")) return {fill: "limegreen", text: "black"};
        return {fill: "gray", text: "white"};
      }

      function updateTrains() {
        const now = parseInt(formatTime(new Date())); // HHMM形式

        const trains = trainGroup.selectAll("g.train")
          .data(data);

        const trainsEnter = trains.enter()
          .append("g")
          .attr("class", "train");

        trainsEnter.append("polygon");
        trainsEnter.append("text")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("font-size", "12px");

        trains.merge(trainsEnter).each(function(d) {
          const g = d3.select(this);
          const pos = getTrainPosition(d, now);

          if (!pos) {
            g.style("display", "none");
            return;
          }
          g.style("display", null);

          const {x, y, direction} = pos;
          const {fill, text} = getStyle(d.train_name);

          const width = 40, height = 20, tip = 10;
          let points;
          if (direction === "up") {
            points = [
              [x - width/2, y - height/2],
              [x + width/2, y - height/2],
              [x + width/2 + tip, y],
              [x + width/2, y + height/2],
              [x - width/2, y + height/2]
            ];
          } else {
            points = [
              [x - width/2 - tip, y],
              [x - width/2, y - height/2],
              [x + width/2, y - height/2],
              [x + width/2, y + height/2],
              [x - width/2, y + height/2]
            ];
          }

          g.select("polygon")
            .attr("points", points.map(p => p.join(",")).join(" "))
            .attr("fill", fill)
            .attr("stroke", "black");

          g.select("text")
            .attr("x", x)
            .attr("y", y)
            .attr("fill", text)
            .text(d.train_name);
        });

        trains.exit().remove();
      }

      setInterval(updateTrains, 1000);
      updateTrains();
    });
  </script>
</body>
</html>
